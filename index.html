<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Question and Answer Extractor</title>
    <!-- Load PDF.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.8.69/pdf.min.mjs" type="module"></script>
    <link rel="stylesheet" type="text/css" href="/api-www/global-elements/global-header/v1/assets/globalheader.css">
</head>
<body>
    <h1>Question and Answer Extractor</h1>
    <p>Upload an image, PDF, text, CSV, or Excel file. The app uses Llama 4 Maverick via OpenRouter to extract passages (for reading comprehension), questions, and answers. Enter your answers and check them; non-exact matches are verified by AI.</p>
    
    <div class="input-section">
        <label for="apiKey">OpenRouter API Key:</label>
        <input type="password" id="apiKey" placeholder="Enter your API key">
        
        <label for="fileType">File Type:</label>
        <select id="fileType">
            <option value="vision">Image or PDF</option>
            <option value="text">Text, CSV, Excel</option>
        </select>
        
        <input type="file" id="fileInput" accept=".jpg,.jpeg,.png,.pdf,.txt,.csv,.xls,.xlsx">
    </div>
    
    <div id="spinner">Processing...</div>
    <div id="output" class="output-section"></div>

    <script type="module">
        import * as pdfjsLib from 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.8.69/pdf.min.mjs';
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.8.69/pdf.worker.min.mjs';

        const apiKeyInput = document.getElementById('apiKey');
        const fileTypeSelect = document.getElementById('fileType');
        const fileInput = document.getElementById('fileInput');
        const outputDiv = document.getElementById('output');
        const spinner = document.getElementById('spinner');

        // Prompt for extraction
        const extractionPrompt = `
From the provided document (image, PDF pages as images, text, CSV, or Excel file representing a quiz, worksheet, textbook, exam, reading comprehension passage, or data file), 
first identify if there's a main passage or reading text (e.g., for reading comprehension), then extract all questions and their corresponding answers or solutions if present. 
Questions are typically phrased with words like "What", "How", "Why", numbers like 1., a., or question marks. Answers may follow questions, be at the end, or be explanations/solutions.
For data files like CSV or Excel, extract any embedded questions or interpret data as potential answers if questions are implied.

Output as JSON with the following structure:
{
  "passage": "Extracted passage or reading text if present, otherwise empty string",
  "qna": [
    {
      "question": "Full question text",
      "answer": "Full answer text, or 'No answer found' if none"
    },
    ...
  ]
}

Only output the JSON object, no additional text.
`;

        // Prompt for verification
        const verifyPromptTemplate = (question, stdAnswer, userAnswer) => `
Question: ${question}
Standard Answer: ${stdAnswer}
User Answer: ${userAnswer}

Determine if the user's answer is correct or equivalent to the standard answer. 
Respond with JSON: {"result": "correct" or "incorrect", "explanation": "Brief explanation"}
`;

        fileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const apiKey = apiKeyInput.value;
            if (!apiKey) {
                outputDiv.innerHTML = '<div class="warning">Please enter your OpenRouter API Key.</div>';
                return;
            }

            spinner.style.display = 'block';
            outputDiv.innerHTML = '';

            try {
                let messageContent = [{ type: 'text', text: extractionPrompt }];

                if (fileTypeSelect.value === 'vision') {
                    if (file.type === 'application/pdf') {
                        const arrayBuffer = await file.arrayBuffer();
                        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                            const page = await pdf.getPage(pageNum);
                            const scale = 1.5;
                            const viewport = page.getViewport({ scale });
                            const canvas = document.createElement('canvas');
                            canvas.height = viewport.height;
                            canvas.width = viewport.width;
                            const context = canvas.getContext('2d');
                            await page.render({ canvasContext: context, viewport }).promise;
                            const imgDataUrl = canvas.toDataURL('image/png');
                            messageContent.push({
                                type: 'image_url',
                                image_url: { url: imgDataUrl }
                            });
                        }
                    } else if (['image/jpeg', 'image/png'].includes(file.type)) {
                        const reader = new FileReader();
                        const imgDataUrl = await new Promise((resolve) => {
                            reader.onload = (e) => resolve(e.target.result);
                            reader.readAsDataURL(file);
                        });
                        messageContent.push({
                            type: 'image_url',
                            image_url: { url: imgDataUrl }
                        });
                    } else {
                        throw new Error('Unsupported file type for vision input.');
                    }
                } else {
                    let textContent;
                    if (file.type === 'text/plain') {
                        textContent = await file.text();
                    } else if (file.type === 'text/csv') {
                        const text = await file.text();
                        textContent = text; // Simplified; for full CSV parsing, use PapaParse
                    } else if (['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'].includes(file.type)) {
                        throw new Error('Excel processing requires server-side libraries; upload CSV instead.');
                        // Client-side Excel parsing is complex; recommend server-side or CSV conversion
                    } else {
                        throw new Error('Unsupported file type for text input.');
                    }
                    messageContent.push({ type: 'text', text: textContent });
                }

                // Call OpenRouter API
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'meta-llama/llama-4-maverick:free',
                        messages: [{ role: 'user', content: messageContent }]
                    })
                });

                if (!response.ok) throw new Error(`API error: ${response.statusText}`);

                const data = await response.json();
                const extractedData = JSON.parse(data.choices[0].message.content);
                const passage = extractedData.passage || '';
                const qnaList = extractedData.qna || [];

                // Display results
                let outputHtml = '';
                if (passage) {
                    outputHtml += `<h2>Passage / Reading Text</h2><p>${passage}</p>`;
                }
                if (qnaList.length) {
                    outputHtml += '<h2>Questions and Answers</h2>';
                    qnaList.forEach((item, idx) => {
                        const question = item.question || '';
                        const stdAnswer = item.answer || 'No answer found';
                        outputHtml += `
                            <div class="qna-item">
                                <details>
                                    <summary><strong>Question ${idx + 1}:</strong> ${question}</summary>
                                    <div class="answer"><strong>Answer:</strong> ${stdAnswer}</div>
                                </details>
                                <input type="text" id="answer_${idx}" placeholder="Your Answer">
                                <button onclick="checkAnswer(${idx}, '${question.replace(/'/g, "\\'")}', '${stdAnswer.replace(/'/g, "\\'")}')">Check Answer</button>
                                <div id="result_${idx}"></div>
                            </div>
                        `;
                    });
                } else {
                    outputHtml += '<div class="info">No questions found in the document.</div>';
                }

                outputDiv.innerHTML = outputHtml;
            } catch (error) {
                outputDiv.innerHTML = `<div class="error">Error: ${error.message}</div>`;
            } finally {
                spinner.style.display = 'none';
            }
        });

        // Check answer function
        async function checkAnswer(idx, question, stdAnswer) {
            const userAnswer = document.getElementById(`answer_${idx}`).value;
            const resultDiv = document.getElementById(`result_${idx}`);
            const apiKey = apiKeyInput.value;

            if (!userAnswer) {
                resultDiv.innerHTML = '<div class="warning">Please enter an answer.</div>';
                return;
            }

            spinner.style.display = 'block';
            resultDiv.innerHTML = '';

            try {
                if (userAnswer.toLowerCase() === stdAnswer.toLowerCase()) {
                    resultDiv.innerHTML = '<div class="info">Correct!</div>';
                } else {
                    const verifyResponse = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'meta-llama/llama-4-maverick:free',
                            messages: [{ role: 'user', content: verifyPromptTemplate(question, stdAnswer, userAnswer) }]
                        })
                    });

                    if (!verifyResponse.ok) throw new Error('Verification API error');

                    const verifyData = await verifyResponse.json();
                    const verifyResult = JSON.parse(verifyData.choices[0].message.content);
                    if (verifyResult.result === 'correct') {
                        resultDiv.innerHTML = `<div class="info">Correct! (AI verified) Explanation: ${verifyResult.explanation}</div>`;
                    } else {
                        resultDiv.innerHTML = `<div class="error">Incorrect. Explanation: ${verifyResult.explanation} The standard answer is: ${stdAnswer}</div>`;
                    }
                }
            } catch (error) {
                resultDiv.innerHTML = `<div class="error">Error verifying: ${error.message}</div>`;
            } finally {
                spinner.style.display = 'none';
            }
        }

        // Expose checkAnswer to global scope for button onclick
        window.checkAnswer = checkAnswer;
    </script>

    <footer>
        <p><strong>Note:</strong> Uses Llama 4 Maverick (free tier) via OpenRouter. PDFs are converted to images client-side with PDF.js. Answers are checked case-insensitively; non-exact matches are AI-verified. CSV is processed as text; Excel requires server-side parsing—convert to CSV for client-side use. No external dependencies except PDF.js CDN.</p>
    </footer>
</body>
</html>
