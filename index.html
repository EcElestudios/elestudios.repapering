<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Question and Answer Extractor</title>
    <!-- Load PDF.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.8.69/pdf.min.mjs" type="module"></script>
    <style>
        :root {
            --primary: #1a73e8;
            --secondary: #f1f3f4;
            --text: #202124;
            --error: #d93025;
            --warning: #fbbc05;
            --info: #34a853;
            --background: #f8f9fa;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--background);
            color: var(--text);
            line-height: 1.6;
        }

        h1 {
            text-align: center;
            color: var(--text);
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
        }

        p {
            text-align: center;
            max-width: 800px;
            margin: 0 auto 2rem;
            color: #5f6368;
        }

        .input-section {
            display: grid;
            gap: 1rem;
            background-color: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
        }

        .output-section {
            margin-top: 2rem;
        }

        .qna-item {
            background-color: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
        }

        .qna-item:hover {
            transform: translateY(-2px);
        }

        .qna-item summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--primary);
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        .answer {
            padding: 1rem;
            background-color: var(--secondary);
            border-left: 4px solid var(--primary);
            border-radius: 8px;
            margin-top: 0.5rem;
        }

        input[type="text"], input[type="password"], select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #dadce0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus, input[type="password"]:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
        }

        button {
            padding: 0.75rem 1.5rem;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s, transform 0.1s;
        }

        button:hover {
            background-color: #1557b0;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        .error, .warning, .info {
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .error { background-color: #fce8e6; color: var(--error); }
        .warning { background-color: #fef7e0; color: var(--warning); }
        .info { background-color: #e6f4ea; color: var(--info); }

        #spinner {
            display: none;
            text-align: center;
            padding: 2rem;
        }

        #spinner::after {
            content: '';
            border: 4px solid #dadce0;
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            width: 2rem;
            height: 2rem;
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #apiKeyContainer {
            display: none;
        }

        @media (max-width: 768px) {
            body { padding: 15px; }
            h1 { font-size: 2rem; }
            .input-section { padding: 1rem; }
            .qna-item { padding: 1rem; }
            button { padding: 0.6rem 1.2rem; }
        }

        @media (max-width: 480px) {
            h1 { font-size: 1.5rem; }
            input[type="text"], input[type="password"], select { font-size: 0.9rem; }
            button { font-size: 0.9rem; }
        }
    </style>
</head>
<body>
    <h1>Question and Answer Extractor</h1>
    <p>Upload an image, PDF, text, CSV, or Excel file to extract passages, questions, and answers. Select an API provider and enter your API key if required. Enter your answers to check them; non-exact matches are AI-verified.</p>
    
    <div class="input-section">
        <label for="apiProvider">API Provider:</label>
        <select id="apiProvider" onchange="toggleApiKeyInput()">
            <option value="openrouter-non-byok">OpenRouter (Non-BYOK, Llama 4 Maverick)</option>
            <option value="xai-byok">xAI (BYOK, Grok 3)</option>
            <option value="openai-byok">OpenAI (BYOK, GPT-4o)</option>
            <option value="openrouter-byok">OpenRouter (BYOK, Llama 4 Maverick)</option>
        </select>
        
        <div id="apiKeyContainer">
            <label for="apiKey">API Key:</label>
            <input type="password" id="apiKey" placeholder="Enter your API key">
        </div>
        
        <label for="fileType">File Type:</label>
        <select id="fileType">
            <option value="vision">Image or PDF</option>
            <option value="text">Text, CSV, Excel</option>
        </select>
        
        <input type="file" id="fileInput" accept=".jpg,.jpeg,.png,.pdf,.txt,.csv,.xls,.xlsx">
    </div>
    
    <div id="spinner"></div>
    <div id="output" class="output-section"></div>

    <script type="module">
        import * as pdfjsLib from 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.8.69/pdf.min.mjs';
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.8.69/pdf.worker.min.mjs';

        const apiProviderSelect = document.getElementById('apiProvider');
        const apiKeyContainer = document.getElementById('apiKeyContainer');
        const apiKeyInput = document.getElementById('apiKey');
        const fileTypeSelect = document.getElementById('fileType');
        const fileInput = document.getElementById('fileInput');
        const outputDiv = document.getElementById('output');
        const spinner = document.getElementById('spinner');

        // Toggle API key input visibility
        function toggleApiKeyInput() {
            apiKeyContainer.style.display = apiProviderSelect.value === 'openrouter-non-byok' ? 'none' : 'block';
        }
        toggleApiKeyInput(); // Initial call

        // Prompt for extraction
        const extractionPrompt = `
From the provided document (image, PDF pages as images, text, CSV, or Excel file representing a quiz, worksheet, textbook, exam, reading comprehension passage, or data file), 
first identify if there's a main passage or reading text (e.g., for reading comprehension), then extract all questions and their corresponding answers or solutions if present. 
Questions are typically phrased with words like "What", "How", "Why", numbers like 1., a., or question marks. Answers may follow questions, be at the end, or be explanations/solutions.
For data files like CSV or Excel, extract any embedded questions or interpret data as potential answers if questions are implied.

Output as JSON with the following structure:
{
  "passage": "Extracted passage or reading text if present, otherwise empty string",
  "qna": [
    {
      "question": "Full question text",
      "answer": "Full answer text, or 'No answer found' if none"
    },
    ...
  ]
}

Only output the JSON object, no additional text.
`;

        // Prompt for verification
        const verifyPromptTemplate = (question, stdAnswer, userAnswer) => `
Question: ${question}
Standard Answer: ${stdAnswer}
User Answer: ${userAnswer}

Determine if the user's answer is correct or equivalent to the standard answer. 
Respond with JSON: {"result": "correct" or "incorrect", "explanation": "Brief explanation"}
`;

        // API configuration
        const getApiConfig = (provider, apiKey) => {
            switch (provider) {
                case 'xai-byok':
                    return {
                        url: 'https://x.ai/api/v1/chat/completions',
                        model: 'grok-3',
                        headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' }
                    };
                case 'openai-byok':
                    return {
                        url: 'https://api.openai.com/v1/chat/completions',
                        model: 'gpt-4o',
                        headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' }
                    };
                case 'openrouter-byok':
                    return {
                        url: 'https://openrouter.ai/api/v1/chat/completions',
                        model: 'meta-llama/llama-4-maverick:free',
                        headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' }
                    };
                case 'openrouter-non-byok':
                    return {
                        url: 'https://openrouter.ai/api/v1/chat/completions',
                        model: 'meta-llama/llama-4-maverick:free',
                        headers: { 'Authorization': `Bearer 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`, 'Content-Type': 'application/json' }
                    };
                default:
                    throw new Error('Invalid API provider selected.');
            }
        };

        fileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const provider = apiProviderSelect.value;
            const apiKey = apiKeyInput.value;
            if (provider !== 'openrouter-non-byok' && !apiKey) {
                outputDiv.innerHTML = '<div class="warning">Please enter your API key for the selected provider.</div>';
                return;
            }

            spinner.style.display = 'block';
            outputDiv.innerHTML = '';

            try {
                let messageContent = [{ type: 'text', text: extractionPrompt }];

                if (fileTypeSelect.value === 'vision') {
                    if (file.type === 'application/pdf') {
                        const arrayBuffer = await file.arrayBuffer();
                        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                            const page = await pdf.getPage(pageNum);
                            const scale = 1.5;
                            const viewport = page.getViewport({ scale });
                            const canvas = document.createElement('canvas');
                            canvas.height = viewport.height;
                            canvas.width = viewport.width;
                            const context = canvas.getContext('2d');
                            await page.render({ canvasContext: context, viewport }).promise;
                            const imgDataUrl = canvas.toDataURL('image/png');
                            messageContent.push({
                                type: 'image_url',
                                image_url: { url: imgDataUrl }
                            });
                        }
                    } else if (['image/jpeg', 'image/png'].includes(file.type)) {
                        const reader = new FileReader();
                        const imgDataUrl = await new Promise((resolve) => {
                            reader.onload = (e) => resolve(e.target.result);
                            reader.readAsDataURL(file);
                        });
                        messageContent.push({
                            type: 'image_url',
                            image_url: { url: imgDataUrl }
                        });
                    } else {
                        throw new Error('Unsupported file type for vision input.');
                    }
                } else {
                    let textContent;
                    if (file.type === 'text/plain') {
                        textContent = await file.text();
                    } else if (file.type === 'text/csv') {
                        const text = await file.text();
                        textContent = text; // Simplified; for full CSV parsing, use PapaParse
                    } else if (['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'].includes(file.type)) {
                        throw new Error('Excel processing requires server-side libraries; upload CSV instead.');
                    } else {
                        throw new Error('Unsupported file type for text input.');
                    }
                    messageContent.push({ type: 'text', text: textContent });
                }

                // Call selected API
                const { url, model, headers } = getApiConfig(provider, apiKey);
                const response = await fetch(url, {
                    method: 'POST',
                    headers,
                    body: JSON.stringify({
                        model,
                        messages: [{ role: 'user', content: messageContent }]
                    })
                });

                if (!response.ok) throw new Error(`API error: ${response.statusText}`);

                const data = await response.json();
                const extractedData = JSON.parse(data.choices[0].message.content);
                const passage = extractedData.passage || '';
                const qnaList = extractedData.qna || [];

                // Display results
                let outputHtml = '';
                if (passage) {
                    outputHtml += `<h2>Passage / Reading Text</h2><p>${passage}</p>`;
                }
                if (qnaList.length) {
                    outputHtml += '<h2>Questions and Answers</h2>';
                    qnaList.forEach((item, idx) => {
                        const question = item.question || '';
                        const stdAnswer = item.answer || 'No answer found';
                        outputHtml += `
                            <div class="qna-item">
                                <details>
                                    <summary><strong>Question ${idx + 1}:</strong> ${question}</summary>
                                    <div class="answer"><strong>Answer:</strong> ${stdAnswer}</div>
                                </details>
                                <input type="text" id="answer_${idx}" placeholder="Your Answer">
                                <button onclick="checkAnswer(${idx}, '${question.replace(/'/g, "\\'")}', '${stdAnswer.replace(/'/g, "\\'")}')">Check Answer</button>
                                <div id="result_${idx}"></div>
                            </div>
                        `;
                    });
                } else {
                    outputHtml += '<div class="info">No questions found in the document.</div>';
                }

                outputDiv.innerHTML = outputHtml;
            } catch (error) {
                outputDiv.innerHTML = `<div class="error">Error: ${error.message}</div>`;
            } finally {
                spinner.style.display = 'none';
            }
        });

        // Check answer function
        async function checkAnswer(idx, question, stdAnswer) {
            const userAnswer = document.getElementById(`answer_${idx}`).value;
            const resultDiv = document.getElementById(`result_${idx}`);
            const provider = apiProviderSelect.value;
            const apiKey = apiKeyInput.value;

            if (!userAnswer) {
                resultDiv.innerHTML = '<div class="warning">Please enter an answer.</div>';
                return;
            }

            if (provider !== 'openrouter-non-byok' && !apiKey) {
                resultDiv.innerHTML = '<div class="warning">Please enter your API key for the selected provider.</div>';
                return;
            }

            spinner.style.display = 'block';
            resultDiv.innerHTML = '';

            try {
                if (userAnswer.toLowerCase() === stdAnswer.toLowerCase()) {
                    resultDiv.innerHTML = '<div class="info">Correct!</div>';
                } else {
                    const { url, model, headers } = getApiConfig(provider, apiKey);
                    const verifyResponse = await fetch(url, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify({
                            model,
                            messages: [{ role: 'user', content: verifyPromptTemplate(question, stdAnswer, userAnswer) }]
                        })
                    });

                    if (!verifyResponse.ok) throw new Error('Verification API error');

                    const verifyData = await verifyResponse.json();
                    const verifyResult = JSON.parse(verifyData.choices[0].message.content);
                    if (verifyResult.result === 'correct') {
                        resultDiv.innerHTML = `<div class="info">Correct! (AI verified) Explanation: ${verifyResult.explanation}</div>`;
                    } else {
                        resultDiv.innerHTML = `<div class="error">Incorrect. Explanation: ${verifyResult.explanation} The standard answer is: ${stdAnswer}</div>`;
                    }
                }
            } catch (error) {
                resultDiv.innerHTML = `<div class="error">Error verifying: ${error.message}</div>`;
            } finally {
                spinner.style.display = 'none';
            }
        }

        // Expose checkAnswer to global scope for button onclick
        window.checkAnswer = checkAnswer;
    </script>

    <footer>
        <p><strong>Note:</strong> Uses the selected API provider and model (xAI: Grok 3, OpenAI: GPT-4o, OpenRouter: Llama 4 Maverick). PDFs are converted to images client-side with PDF.js. Answers are checked case-insensitively; non-exact matches are AI-verified. CSV is processed as text; Excel requires server-side parsing—convert to CSV for client-side use. No external dependencies except PDF.js CDN.</p>
    </footer>
</body>
</html>
